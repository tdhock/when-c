Comparing .C and Rcpp implementations of binary segmentation

** Introduction

Binary segmentation is a heuristic/approximate algorithm for finding a
set of changepoints in a sequence data set. There are several
implementations available, including [[https://cloud.r-project.org/web/packages/changepoint/][changepoint::cpt.mean]] and
[[https://cloud.r-project.org/web/packages/fpop/][fpop::multiBinSeg]] in R, and [[http://ctruong.perso.math.cnrs.fr/ruptures-docs/build/html/detection/binseg.html][ruptures.detection.BinSeg]] in Python. A
good overview of this classic algorithm is given by [[https://arxiv.org/abs/1801.00718][Truong et al,
arXiv:1801.00718]].

** My efficient C++ implementation

I used C++ to implement binary segmentation using the square loss
(normal distribution with constant variance) for a univariate real
data sequence. The key data structures are containers from the C++
Standard Template Library (STL):
- [[http://www.cplusplus.com/reference/map/multimap/][multimap]] stores the set of possible split points (ordered by how
  much the cost would decrease if the split is used).
- [[http://www.cplusplus.com/reference/vector/vector/][vector]] stores the set of segments (with corresponding
  cost/parameters/etc).
There are two different R packages, [[https://github.com/tdhock/binseg][binseg]] (which uses the .C
interface) and [[https://github.com/tdhock/binsegRcpp][binsegRcpp]] (which uses the Rcpp interface). The main
algorithm is implemented in src/binseg_normal.cpp in both
packages. 

** Differences between interfaces

The differences between the packages are in the interface
files and dependencies. Below we classify the differences in terms of
which interface system has an advantage (easier to maintain or more
flexible).

Advantage: =Rcpp=.

- the interface function in binsegRcpp/src/rcpp_binseg_normal.cpp
  inputs two arguments (Rcpp::NumericVector, Rcpp::IntegerVector) and
  returns a Rcpp::List, whereas the interface function in
  binseg/src/interface.cpp inputs 11 arguments (each is int* or
  double*) and returns void. Understanding the inputs/outputs of the
  binsegRcpp version is easier than the binseg version.
- type checking R code must be written in binseg/R/binseg_normal.R
  whereas such type checking code is automatically generated by
  Rcpp. 
- binseg/src/interface.cpp includes manually written code for
  registering routines (with potential for mis-match between
  registered arguments and actual arguments), whereas the
  automatically generated binsegRcpp/src/RcppExports.cpp includes the
  analogous registration code. 
- binsegRcpp/R/RcppExports.R is automatically generated whereas
  binseg/R/binseg_normal.R must be written by hand (with potential for
  mis-match between arguments in R/C++ code). 

Advantage: =.C=.

- binsegRcpp has a hard dependency (Imports, LinkingTo) on Rcpp for
  the interface, whereas binseg uses .C in base R (no other dependency
  for the interface). 
- non-finite values are typically not used/desired in C++
  routines. Rcpp has functions ([[https://teuder.github.io/rcpp4everyone_en/240_na_nan_inf.html][is_na, is_nan, is_infinite]]) to
  check for these; in contrast .C stops with an error by
  default. 
- Documentation/examples may be specified in =//'= roxygen comments in
  the binsegRcpp/src/rcpp_binseg_normal.cpp interface file (as
  explained in section 3.5 of the [[http://dirk.eddelbuettel.com/code/rcpp/Rcpp-attributes.pdf][Rcpp attributes vignette]]), which are
  translated by Rcpp::compileAttributes to =#'= comments in the
  binsegRcpp/src/RcppExports.cpp file. Docs/examples may be written
  directly in the binseg/R/binseg_normal.R file, which is a bit more
  flexible (e.g. other doc-generation systems like [[https://github.com/tdhock/inlinedocs][inlinedocs]] and [[http://www.aroma-project.org/developers/][Rdoc]]
  may be used). 

No advantage for either interface.

- error handling in binsegRcpp/src/rcpp_binseg_normal.cpp and
  binseg/src/interface.cpp is pretty much the same (stop for non-zero
  integer status code).
- memory allocation for the output vectors is performed in
  binseg/R/binseg_normal.R and binsegRcpp/src/rcpp_binseg_normal.cpp.

Overall, I would suggest that the =Rcpp= interface should be preferred
if you are willing to introduce a hard dependency on Rcpp and use
roxygen2 for documentation. Using either interface I think it is
important to separate the interface code (which depends on the
high-level language/system) from the main algorithm (which should be
portable to different high-level languages/systems such as R, Python,
julia, etc). In particular the main algorithm should be
implemented as a function (1) that uses standard int/double data types
for input/output arguments and (2) that returns an integer error
status code.


